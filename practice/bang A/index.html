<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tr√¨nh xem b√†i t·∫≠p Tin h·ªçc tr·∫ª</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .left-panel {
            width: 400px;
            background: white;
            border-right: 2px solid #e0e0e0;
            display: flex;
            flex-direction: column;
        }

        .right-panel {
            flex: 1;
            background: white;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            font-weight: bold;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .right-panel .panel-header {
            display: none;
        }

        .problem-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .problem-item {
            padding: 12px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
            position: relative;
        }

        .problem-item:hover {
            background: #f8f9ff;
            border-color: #667eea;
            transform: translateX(5px);
        }

        .problem-item.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }

        .problem-title {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .problem-contest {
            font-size: 12px;
            color: #666;
            margin-bottom: 6px;
        }

        .problem-item.active .problem-contest {
            color: #e0e0e0;
        }

        .problem-meta-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
            flex-wrap: nowrap;
            overflow: hidden;
        }

        .problem-id {
            font-size: 11px;
            color: #888;
            font-family: monospace;
            flex-shrink: 0;
            min-width: 0;
        }

        .problem-item.active .problem-id {
            color: #ccc;
        }

        .problem-difficulty {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 9px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.2px;
            flex-shrink: 0;
            min-width: 0;
        }

        .problem-difficulty.d·ªÖ {
            background: #4CAF50;
            color: white;
        }

        .problem-difficulty.trung-b√¨nh {
            background: #FF9800;
            color: white;
        }

        .problem-difficulty.kh√≥ {
            background: #FF5722;
            color: white;
        }

        .problem-difficulty.r·∫•t-kh√≥ {
            background: #9C27B0;
            color: white;
        }

        .problem-tags-list {
            display: flex;
            flex-wrap: nowrap;
            gap: 3px;
            flex: 1;
            justify-content: flex-end;
            overflow: hidden;
            min-width: 0;
        }

        .problem-tag {
            display: inline-block;
            padding: 2px 5px;
            background: #e3f2fd;
            color: #1976d2;
            border-radius: 6px;
            font-size: 8px;
            font-weight: 500;
            max-width: 45px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex-shrink: 1;
            min-width: 0;
        }

        .problem-item.active .problem-tag {
            background: rgba(255, 255, 255, 0.2);
            color: #e0e0e0;
        }

        .problem-item.active .problem-difficulty {
            opacity: 0.9;
        }

        /* Tooltip styles */
        .tooltip {
            position: fixed;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            max-width: 250px;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            pointer-events: none;
            word-wrap: break-word;
        }

        .tooltip::before {
            content: '';
            position: absolute;
            top: -5px;
            left: 10px;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 5px solid #333;
        }

        .tooltip.show {
            opacity: 1;
            visibility: visible;
        }

        .content-area {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .welcome-message {
            text-align: center;
            color: #666;
            font-size: 18px;
            margin-top: 100px;
        }

        .loading-indicator {
            text-align: center;
            color: #667eea;
            font-size: 16px;
            margin-top: 100px;
        }

        .loading-indicator i {
            font-size: 24px;
            margin-bottom: 10px;
        }

        .loading-indicator.hide {
            display: none;
        }

        .welcome-message.hide {
            display: none;
        }

        .problem-content {
            display: none;
        }

        .problem-content.active {
            display: block;
        }

        .problem-content h1 {
            color: #333;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .problem-html {
            line-height: 1.6;
        }

        .problem-html p {
            margin-bottom: 15px;
        }

        .problem-html h5,
        .problem-html h6 {
            color: #333;
            margin: 30px 0 15px 0;
            font-weight: 600;
            font-size: 16px;
            padding: 0;
            position: relative;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .problem-html ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .problem-html pre {
            background: #f8f9fa;
            padding: 16px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 15px 0;
            border: 1px solid #e9ecef;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
            line-height: 1.5;
            position: relative;
        }

        /* Section containers with Codeforces/LeetCode styling */
        .section-container {
            margin: 25px 0;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .section-header {
            padding: 12px 16px;
            font-weight: 600;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            position: relative;
        }

        .section-content {
            padding: 16px;
            background: #ffffff;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        /* Input section */
        .input-section .section-header {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            color: #495057;
            border-left: 4px solid #28a745;
        }

        .input-section .section-header::before {
            content: "‚¨á";
            margin-right: 8px;
            font-size: 16px;
        }

        /* Output section */
        .output-section .section-header {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            color: #1565c0;
            border-left: 4px solid #2196f3;
        }

        .output-section .section-header::before {
            content: "‚¨Ü";
            margin-right: 8px;
            font-size: 16px;
        }

        /* Examples section */
        .examples-section .section-header {
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            color: #ef6c00;
            border-left: 4px solid #ff9800;
        }

        .examples-section .section-header::before {
            content: "üîç";
            margin-right: 8px;
            font-size: 16px;
        }

        /* Explanation section */
        .explanation-section .section-header {
            background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%);
            color: #7b1fa2;
            border-left: 4px solid #9c27b0;
        }

        .explanation-section .section-header::before {
            content: "üí°";
            margin-right: 8px;
            font-size: 16px;
        }

        /* Sample input/output styling */
        .sample-container {
            margin: 15px 0;
        }

        .sample-label {
            font-weight: 600;
            color: #666;
            margin-bottom: 8px;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .sample-content {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 12px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
            line-height: 1.4;
            white-space: pre-wrap;
            position: relative;
        }

        .sample-content::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: #667eea;
            border-radius: 2px 0 0 2px;
        }

        /* Copy button for sample content */
        .sample-container {
            position: relative;
        }

        .copy-button {
            position: absolute;
            top: 8px;
            right: 8px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            color: #666;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .sample-container:hover .copy-button {
            opacity: 1;
        }

        .copy-button:hover {
            background: #e9ecef;
            color: #333;
        }

        /* Strong text in sections */
        .section-content strong {
            color: #2c3e50;
            font-weight: 600;
        }

        /* Math expressions styling */
        .MathJax_Display {
            margin: 16px 0 !important;
        }

        .MathJax {
            font-size: 1.1em !important;
        }

        .problem-html code {
            background: #f1f3f4;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            color: #d73a49;
            border: 1px solid #e1e4e8;
        }

        /* Enhanced list styling */
        .problem-html ul {
            margin-left: 0;
            margin-bottom: 20px;
            padding-left: 0;
        }

        .problem-html li {
            list-style: none;
            padding: 8px 0 8px 24px;
            position: relative;
            margin-bottom: 4px;
        }

        .problem-html li::before {
            content: "‚Ä¢";
            color: #667eea;
            font-weight: bold;
            position: absolute;
            left: 8px;
        }

        /* Constraints styling */
        .section-content ul li {
            background: #f8f9fa;
            border-left: 3px solid #667eea;
            border-radius: 0 4px 4px 0;
            padding: 10px 12px;
            margin: 6px 0;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
        }

        .section-content ul li::before {
            content: "‚ñ∂";
            color: #667eea;
            margin-right: 8px;
            position: static;
        }

        .problem-html img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 15px auto;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
        }

        .problem-html img:hover {
            transform: scale(1.02);
        }

        .problem-html img[src*="local-imgs"] {
            border: 2px dashed #f39c12;
            background: #fff3cd;
            padding: 10px;
        }

        .problem-html img[src*="local-imgs"]:after {
            content: "Local image not available";
            display: block;
            text-align: center;
            color: #856404;
            font-style: italic;
            margin-top: 10px;
        }

        .pdf-container {
            width: 100%;
            height: calc(100vh - 120px);
            min-height: 600px;
            border: none;
        }

        .pdf-content {
            height: calc(100vh - 120px);
            min-height: 600px;
            position: relative;
        }

        .pdf-fallback {
            display: none;
            text-align: center;
            padding: 40px;
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            margin-top: 20px;
        }

        .pdf-fallback.show {
            display: block;
        }

        .pdf-fallback .icon {
            font-size: 48px;
            color: #6c757d;
            margin-bottom: 15px;
        }

        .pdf-fallback .message {
            color: #6c757d;
            margin-bottom: 15px;
        }

        .pdf-fallback .link {
            display: inline-block;
            padding: 10px 20px;
            background: #667eea;
            color: white;
            text-decoration: none;
            border-radius: 5px;
            transition: background 0.3s;
        }

        .pdf-fallback .link:hover {
            background: #5a6fd8;
        }

        .search-box {
            padding: 10px;
            border-bottom: 1px solid #ddd;
        }

        .search-box input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 20px;
            font-size: 14px;
            outline: none;
        }

        .search-box input:focus {
            border-color: #667eea;
            box-shadow: 0 0 5px rgba(102, 126, 234, 0.3);
        }

        .problem-type {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
            margin-left: 5px;
        }

        .problem-type.html {
            background: #e3f2fd;
            color: #1976d2;
        }

        .problem-type.pdf {
            background: #fff3e0;
            color: #f57c00;
        }

        .local-indicator {
            display: inline-block;
            padding: 4px 8px;
            background: #4caf50;
            color: white;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
            box-shadow: 0 2px 4px rgba(76, 175, 80, 0.3);
            display: none;
        }

        .local-pdf-indicator {
            display: inline-block;
            margin-right: 5px;
            font-size: 12px;
            padding: 2px 4px;
            background: #4caf50;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 1;
            cursor: help;
        }

        .problem-item.active .local-pdf-indicator {
            background: rgba(255, 255, 255, 0.2);
        }

        .difficulty-filter {
            font-size: 11px;
            margin-left: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 4px 8px;
            color: white;
            outline: none;
            cursor: pointer;
        }

        .difficulty-filter option {
            background: #667eea;
            color: white;
        }

        .language-toggle {
            font-size: 11px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 4px 8px;
            color: white;
            outline: none;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .language-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .language-toggle i {
            font-size: 12px;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="left-panel">
            <div class="panel-header">
                <i class="fas fa-list"></i> Danh s√°ch b√†i t·∫≠p
                <div class="header-controls">
                    <select id="difficultyFilter" class="difficulty-filter" title="L·ªçc theo ƒë·ªô kh√≥">
                        <option value="">T·∫•t c·∫£ ƒë·ªô kh√≥</option>
                        <option value="d·ªÖ">D·ªÖ</option>
                        <option value="trung b√¨nh">Trung b√¨nh</option>
                        <option value="kh√≥">Kh√≥</option>
                        <option value="r·∫•t kh√≥">R·∫•t kh√≥</option>
                    </select>
                    <button id="languageToggle" class="language-toggle" title="Chuy·ªÉn ƒë·ªïi ng√¥n ng·ªØ">
                        <i class="fas fa-language"></i> VI
                    </button>
                </div>
            </div>
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="T√¨m ki·∫øm b√†i t·∫≠p...">
            </div>
            <div class="problem-list" id="problemList">
                <!-- Problems will be loaded here -->
            </div>
        </div>

        <div class="right-panel">
            <div class="panel-header">
                <i class="fas fa-eye"></i> N·ªôi dung b√†i t·∫≠p
            </div>
            <div class="content-area" id="contentArea">
                <div id="loadingIndicator" class="loading-indicator">
                    <i class="fas fa-spinner fa-spin"></i>
                    <p>ƒêang t·∫£i d·ªØ li·ªáu...</p>
                </div>
                <div id="welcomeMessage" class="welcome-message hide">
                    <h2>Ch√†o m·ª´ng ƒë·∫øn v·ªõi tr√¨nh xem b√†i t·∫≠p!</h2>
                    <p>Ch·ªçn m·ªôt b√†i t·∫≠p t·ª´ danh s√°ch b√™n tr√°i ƒë·ªÉ xem n·ªôi dung.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- MathJax Configuration -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['~', '~'], ['$', '$']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            "HTML-CSS": {
                availableFonts: ["TeX"],
                linebreaks: { automatic: true }
            }
        });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>

    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <script>
        let allProblems = {};
        let currentProblemId = null;
        let localPdfCache = new Map(); // Cache for local PDF existence checks
        let currentDifficultyFilter = ''; // Current difficulty filter
        let isLoadingFromHash = false; // Flag to prevent infinite loops during hash loading
        let currentLanguage = 'vi'; // Default language
        let translationCache = new Map(); // Cache for translations
        let isTranslating = false; // Flag to prevent multiple simultaneous translations
        let translationTimeout = null;

        // Vietnamese diacritics removal function
        function removeDiacritics(str) {
            return str.normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '') // Remove combining diacritical marks
                .replace(/ƒë/g, 'd')
                .replace(/ƒê/g, 'D');
        }

        // Normalize text for search (remove diacritics, lowercase, normalize spaces)
        function normalizeForSearch(text) {
            return removeDiacritics(text)
                .toLowerCase()
                .replace(/\s+/g, ' ') // Replace multiple spaces with single space
                .trim();
        }

        // Language dictionaries
        const languageDict = {
            vi: {
                title: 'Tr√¨nh xem b√†i t·∫≠p Tin h·ªçc tr·∫ª',
                problemList: 'Danh s√°ch b√†i t·∫≠p',
                allDifficulties: 'T·∫•t c·∫£ ƒë·ªô kh√≥',
                easy: 'D·ªÖ',
                medium: 'Trung b√¨nh',
                hard: 'Kh√≥',
                veryHard: 'R·∫•t kh√≥',
                searchPlaceholder: 'T√¨m ki·∫øm b√†i t·∫≠p...',
                welcomeTitle: 'Ch√†o m·ª´ng ƒë·∫øn v·ªõi tr√¨nh xem b√†i t·∫≠p!',
                welcomeText: 'Ch·ªçn m·ªôt b√†i t·∫≠p t·ª´ danh s√°ch b√™n tr√°i ƒë·ªÉ xem n·ªôi dung.',
                loading: 'ƒêang t·∫£i d·ªØ li·ªáu...',
                errorLoadingProblems: 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch b√†i t·∫≠p',
                errorLoadingData: 'L·ªói t·∫£i d·ªØ li·ªáu',
                contest: 'Kh√¥ng x√°c ƒë·ªãnh',
                problem: 'B√†i',
                localPdfTooltip: 'File PDF ƒë√£ t·∫£i v·ªÅ local',
                pdfCannotDisplay: 'Kh√¥ng th·ªÉ hi·ªÉn th·ªã PDF trong tr√¨nh duy·ªát',
                openInNewTab: 'M·ªü trong tab m·ªõi',
                download: 'T·∫£i xu·ªëng',
                tryDisplayInBrowser: 'Th·ª≠ hi·ªÉn th·ªã trong tr√¨nh duy·ªát',
                googleDriveFile: 'File PDF t·ª´ Google Drive',
                securityRestriction: 'Do h·∫°n ch·∫ø b·∫£o m·∫≠t, kh√¥ng th·ªÉ hi·ªÉn th·ªã tr·ª±c ti·∫øp trong tr√¨nh duy·ªát',
                notDownloadedLocal: 'File PDF ch∆∞a ƒë∆∞·ª£c t·∫£i v·ªÅ local folder',
                expectedFilename: 'T√™n file mong ƒë·ª£i:',
                viewOnGoogleDrive: 'Xem tr√™n Google Drive',
                cannotLoadPdf: 'Kh√¥ng th·ªÉ t·∫£i PDF. Vui l√≤ng s·ª≠ d·ª•ng c√°c li√™n k·∫øt b√™n tr√™n.',
                languageToggleTooltip: 'Chuy·ªÉn ƒë·ªïi ng√¥n ng·ªØ'
            },
            en: {
                title: 'Tin h·ªçc tr·∫ª Problem Viewer',
                problemList: 'Problem List',
                allDifficulties: 'All Difficulties',
                easy: 'Easy',
                medium: 'Medium',
                hard: 'Hard',
                veryHard: 'Very Hard',
                searchPlaceholder: 'Search problems...',
                welcomeTitle: 'Welcome to the Problem Viewer!',
                welcomeText: 'Select a problem from the left list to view its content.',
                loading: 'Loading data...',
                errorLoadingProblems: 'Cannot load problem list',
                errorLoadingData: 'Error loading data',
                contest: 'Unknown',
                problem: 'Problem',
                localPdfTooltip: 'PDF file downloaded locally',
                pdfCannotDisplay: 'Cannot display PDF in browser',
                openInNewTab: 'Open in new tab',
                download: 'Download',
                tryDisplayInBrowser: 'Try to display in browser',
                googleDriveFile: 'PDF file from Google Drive',
                securityRestriction: 'Due to security restrictions, cannot display directly in browser',
                notDownloadedLocal: 'PDF file not downloaded to local folder',
                expectedFilename: 'Expected filename:',
                viewOnGoogleDrive: 'View on Google Drive',
                cannotLoadPdf: 'Cannot load PDF. Please use the links above.',
                languageToggleTooltip: 'Switch language'
            }
        };

        // Language management functions
        function getCurrentLanguage() {
            return localStorage.getItem('problemViewerLanguage') || 'vi';
        }

        function setCurrentLanguage(lang) {
            currentLanguage = lang;
            localStorage.setItem('problemViewerLanguage', lang);
            updateLanguageToggleButton();
        }

        function updateLanguageToggleButton() {
            const btn = document.getElementById('languageToggle');
            if (btn) {
                btn.innerHTML = `<i class="fas fa-language"></i> ${currentLanguage.toUpperCase()}`;
                btn.title = languageDict[currentLanguage].languageToggleTooltip;
            }
        }

        function getTranslation(key) {
            return languageDict[currentLanguage][key] || languageDict.vi[key] || key;
        }

        // Translation functions using Google Translate API
        async function translateText(text, targetLang) {
            if (!text || text.trim() === '') return text;
            
            const cacheKey = `${text}_${targetLang}`;
            if (translationCache.has(cacheKey)) {
                return translationCache.get(cacheKey);
            }

            try {
                console.log(`Translating: "${text.substring(0, 50)}..." to ${targetLang}`);
                
                // Add timeout to prevent hanging
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
                
                // Use Google Translate API via free service
                const response = await fetch(`https://translate.googleapis.com/translate_a/single?client=gtx&sl=auto&tl=${targetLang}&dt=t&q=${encodeURIComponent(text)}`, {
                    signal: controller.signal,
                    method: 'GET',
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                    }
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result && result[0] && result[0][0]) {
                    const translatedText = result[0].map(item => item[0]).join('');
                    translationCache.set(cacheKey, translatedText);
                    console.log(`Translation successful: "${translatedText.substring(0, 50)}..."`);
                    return translatedText;
                } else {
                    console.warn('Invalid translation response format');
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.warn('Translation timeout:', text.substring(0, 50));
                } else {
                    console.warn('Translation failed:', error.message, 'for text:', text.substring(0, 50));
                }
            }
            
            return text; // Return original text if translation fails
        }

        async function translatePageElements() {
            if (isTranslating) {
                console.log('Translation already in progress, skipping');
                return;
            }
            
            isTranslating = true;
            console.log('Starting page translation');

            // Set a safety timeout to reset translation state if it gets stuck
            translationTimeout = setTimeout(() => {
                console.warn('Translation took too long, forcing reset');
                isTranslating = false;
                const button = document.getElementById('languageToggle');
                if (button) {
                    button.disabled = false;
                    button.style.opacity = '1';
                    button.style.cursor = 'pointer';
                }
            }, 30000); // 30 second safety timeout

            try {
                // Update static UI elements
                updateStaticUIElements();
                
                // If English is selected, translate dynamic content
                if (currentLanguage === 'en') {
                    await translateDynamicContent();
                }
                
                // Re-render problem list to apply translations
                const hashParams = getHashParams();
                await renderProblemList(hashParams.search);
                
                // Re-translate current problem content if displayed
                if (currentProblemId) {
                    const problemUrl = Object.keys(allProblems).find(url => 
                        url.split('/').pop() === currentProblemId
                    );
                    if (problemUrl) {
                        await displayProblem(allProblems[problemUrl]);
                    }
                }
                console.log('Page translation completed');
            } catch (error) {
                console.error('Error during page translation:', error);
                throw error; // Re-throw to be handled by caller
            } finally {
                // Clear safety timeout and reset flag
                if (translationTimeout) {
                    clearTimeout(translationTimeout);
                    translationTimeout = null;
                }
                isTranslating = false;
                console.log('Translation flag reset');
            }
        }

        function updateStaticUIElements() {
            // Update title
            document.title = getTranslation('title');
            
            // Update panel headers
            const panelHeader = document.querySelector('.panel-header');
            if (panelHeader) {
                const icon = panelHeader.querySelector('i');
                const iconHTML = icon ? icon.outerHTML : '<i class="fas fa-list"></i>';
                const controlsDiv = panelHeader.querySelector('.header-controls');
                const controlsHTML = controlsDiv ? controlsDiv.outerHTML : '';
                panelHeader.innerHTML = `${iconHTML} ${getTranslation('problemList')} ${controlsHTML}`;
            }
            
            // Update difficulty filter options
            const difficultyFilter = document.getElementById('difficultyFilter');
            if (difficultyFilter) {
                const currentValue = difficultyFilter.value;
                difficultyFilter.innerHTML = `
                    <option value="">${getTranslation('allDifficulties')}</option>
                    <option value="d·ªÖ">${getTranslation('easy')}</option>
                    <option value="trung b√¨nh">${getTranslation('medium')}</option>
                    <option value="kh√≥">${getTranslation('hard')}</option>
                    <option value="r·∫•t kh√≥">${getTranslation('veryHard')}</option>
                `;
                difficultyFilter.value = currentValue;
                difficultyFilter.title = getTranslation('allDifficulties');
            }
            
            // Update search placeholder
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.placeholder = getTranslation('searchPlaceholder');
            }
            
            // Update welcome message
            const welcomeMessage = document.getElementById('welcomeMessage');
            if (welcomeMessage) {
                welcomeMessage.innerHTML = `
                    <h2>${getTranslation('welcomeTitle')}</h2>
                    <p>${getTranslation('welcomeText')}</p>
                `;
            }
            
            // Update loading indicator
            const loadingIndicator = document.getElementById('loadingIndicator');
            if (loadingIndicator) {
                loadingIndicator.innerHTML = `
                    <i class="fas fa-spinner fa-spin"></i>
                    <p>${getTranslation('loading')}</p>
                `;
            }
        }

        async function translateDynamicContent(problemData) {
            // This function will translate dynamic content for a specific problem
            if (getCurrentLanguage() === 'en') {
                if (problemData.contest && problemData.contest !== 'Kh√¥ng x√°c ƒë·ªãnh' && !problemData.contestTranslated) {
                    const translatedContest = await translateText(problemData.contest, 'en');
                    problemData.contestTranslated = translatedContest;
                }
                
                if (problemData.title && !problemData.titleTranslated) {
                    const translatedTitle = await translateText(problemData.title, 'en');
                    problemData.titleTranslated = translatedTitle;
                }
                
                if (problemData.shortDescription && !problemData.shortDescriptionTranslated) {
                    const translatedShortDescription = await translateText(problemData.shortDescription, 'en');
                    problemData.shortDescriptionTranslated = translatedShortDescription;
                }
                
                if (problemData.html && !problemData.htmlTranslated) {
                    const translatedHtml = await translateText(problemData.html, 'en');
                    problemData.htmlTranslated = translatedHtml;
                }
            }
        }

        // URL hash routing functions
        function getHashParams() {
            const hash = window.location.hash.slice(1);
            const params = new URLSearchParams(hash);
            return {
                problemId: params.get('problem'),
                search: params.get('search') || '',
                difficulty: params.get('difficulty') || ''
            };
        }

        function updateHash(problemId = null, search = '', difficulty = '') {
            const params = new URLSearchParams();
            
            if (problemId) {
                params.set('problem', problemId);
            }
            if (search) {
                params.set('search', search);
            }
            if (difficulty) {
                params.set('difficulty', difficulty);
            }

            const newHash = params.toString();
            if (newHash) {
                window.location.hash = newHash;
            } else {
                // Clear hash if no parameters
                history.replaceState(null, null, window.location.pathname);
            }
        }

        async function loadFromHash() {
            isLoadingFromHash = true;
            const hashParams = getHashParams();
            
            // Restore search input
            if (hashParams.search) {
                document.getElementById('searchInput').value = hashParams.search;
            }
            
            // Restore difficulty filter
            if (hashParams.difficulty) {
                currentDifficultyFilter = hashParams.difficulty;
                document.getElementById('difficultyFilter').value = hashParams.difficulty;
            }
            
            // Load specific problem if specified (after rendering problem list)
            if (hashParams.problemId) {
                currentProblemId = hashParams.problemId;
                // Find the problem URL
                const problemUrl = Object.keys(allProblems).find(url => 
                    url.split('/').pop() === hashParams.problemId
                );
                if (problemUrl) {
                    // Wait a bit longer to ensure problem list is rendered, then scroll
                    setTimeout(async () => {
                        isLoadingFromHash = false; // Reset flag before calling selectProblem
                        await selectProblem(hashParams.problemId, problemUrl, allProblems[problemUrl], true);
                    }, 200);
                } else {
                    isLoadingFromHash = false;
                }
            } else {
                isLoadingFromHash = false;
            }
        }

        // Load problems data
        async function loadProblems() {
            try {
                const problemsResponse = await fetch('./allProblems.json');
                allProblems = await problemsResponse.json();

                // Hide loading indicator and show welcome message
                document.getElementById('loadingIndicator').classList.add('hide');
                document.getElementById('welcomeMessage').classList.remove('hide');

                // Load state from URL hash
                await loadFromHash();

                // Render problem list with current filters
                const hashParams = getHashParams();
                await renderProblemList(hashParams.search);
            } catch (error) {
                console.error('Error loading problems:', error);
                document.getElementById('loadingIndicator').classList.add('hide');
                document.getElementById('problemList').innerHTML =
                    '<div style="padding: 20px; text-align: center; color: #f44336;">Kh√¥ng th·ªÉ t·∫£i danh s√°ch b√†i t·∫≠p</div>';
                document.getElementById('contentArea').innerHTML =
                    '<div style="padding: 20px; text-align: center; color: #f44336;">L·ªói t·∫£i d·ªØ li·ªáu</div>';
            }
        }

        // Render problem list
        async function renderProblemList(filterText = '') {
            const problemList = document.getElementById('problemList');
            problemList.innerHTML = '';

            const problemEntries = Object.entries(allProblems);

            for (const [url, problemData] of problemEntries) {
                const problemId = url.split('/').pop();
                
                // Use translated content when English is selected
                const currentLang = getCurrentLanguage();
                const title = currentLang === 'en' && problemData.titleTranslated 
                    ? problemData.titleTranslated 
                    : problemData.title || `B√†i ${problemId}`;
                const contest = currentLang === 'en' && problemData.contestTranslated 
                    ? problemData.contestTranslated 
                    : problemData.contest || 'Kh√¥ng x√°c ƒë·ªãnh';
                const difficulty = problemData.difficulty || '';
                const tags = problemData.tags || [];
                const shortDescription = currentLang === 'en' && problemData.shortDescriptionTranslated 
                    ? problemData.shortDescriptionTranslated 
                    : problemData.shortDescription || '';

                // Filter problems
                // Text search filter
                if (filterText && !searchMatch(filterText, title) &&
                    !searchMatch(filterText, contest) &&
                    !searchMatch(filterText, problemId) &&
                    !searchMatch(filterText, shortDescription) &&
                    !tags.some(tag => searchMatch(filterText, tag))) {
                    continue;
                }

                // Difficulty filter
                if (currentDifficultyFilter && 
                    normalizeForSearch(difficulty) !== normalizeForSearch(currentDifficultyFilter)) {
                    continue;
                }

                const problemItem = document.createElement('div');
                problemItem.className = 'problem-item';
                problemItem.setAttribute('data-problem-id', problemId);
                problemItem.setAttribute('data-url', url);

                const hasHtml = problemData.html;
                const hasPdf = problemData.pdf;
                const problemType = hasHtml ? 'html' : 'pdf';

                // Check if local PDF exists for PDF problems
                let hasLocalPdf = false;
                if (hasPdf) {
                    if (problemData.contest && problemData.title && problemData.index) {
                        const localPdfPath = getLocalPdfPath(problemData.contest, problemData.title, problemData.index);
                        hasLocalPdf = await checkLocalPdfExists(localPdfPath);
                    }
                }

                // Create tags HTML
                let tagsHtml = '';
                if (tags && tags.length > 0) {
                    const displayTags = tags.slice(0, 2); // Show maximum 2 tags to save space
                    tagsHtml = displayTags.map(tag => `<span class="problem-tag" title="${tag}">${tag}</span>`).join('') +
                        (tags.length > 2 ? `<span class="problem-tag">+${tags.length - 2}</span>` : '');
                }

                // Add local PDF indicator
                const localIndicator = hasLocalPdf ? '<span class="local-pdf-indicator" title="File PDF ƒë√£ t·∫£i v·ªÅ local">üìÅ</span>' : '';

                problemItem.innerHTML = `
                    <div class="problem-title">
                        ${title}
                        <div>
                            ${localIndicator}
                            <span class="problem-type ${problemType}">${problemType.toUpperCase()}</span>
                        </div>
                    </div>
                    <div class="problem-contest">${contest}</div>
                    <div class="problem-meta-row">
                        <span class="problem-id">${problemId}</span>
                        ${difficulty ? `<div class="problem-difficulty ${difficulty.toLowerCase().replace(/\s+/g, '-').normalize('NFD').replace(/[\u0300-\u036f]/g, '')}">${difficulty}</div>` : ''}
                        <div class="problem-tags-list">
                            ${tagsHtml}
                        </div>
                    </div>
                `;

                // Add tooltip if shortDescription exists
                if (shortDescription) {
                    problemItem.addEventListener('mouseenter', (e) => {
                        showTooltip(e.target, shortDescription);
                    });
                    problemItem.addEventListener('mouseleave', () => {
                        hideTooltip();
                    });
                }

                problemItem.addEventListener('click', () => {
                    selectProblem(problemId, url, problemData);
                });

                problemList.appendChild(problemItem);
            }
        }

        // Tooltip functions
        let currentTooltip = null;

        function showTooltip(element, text) {
            hideTooltip(); // Hide any existing tooltip

            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            tooltip.textContent = text;
            document.body.appendChild(tooltip);

            const rect = element.getBoundingClientRect();
            tooltip.style.left = (rect.left + 10) + 'px';
            tooltip.style.top = (rect.bottom + 5) + 'px';

            // Adjust position if tooltip goes off screen
            const tooltipRect = tooltip.getBoundingClientRect();
            if (tooltipRect.right > window.innerWidth) {
                tooltip.style.left = (window.innerWidth - tooltipRect.width - 10) + 'px';
            }
            if (tooltipRect.bottom > window.innerHeight) {
                tooltip.style.top = (rect.top - tooltipRect.height - 5) + 'px';
                // Move arrow to bottom
                tooltip.style.setProperty('--arrow-position', 'bottom');
            }

            setTimeout(() => tooltip.classList.add('show'), 10);
            currentTooltip = tooltip;
        }

        function hideTooltip() {
            if (currentTooltip) {
                currentTooltip.remove();
                currentTooltip = null;
            }
        }

        // Select and display problem
        async function selectProblem(problemId, url, problemData, shouldScroll = false) {
            // Update active state
            document.querySelectorAll('.problem-item').forEach(item => {
                item.classList.remove('active');
            });
            
            const targetItem = document.querySelector(`[data-problem-id="${problemId}"]`);
            if (targetItem) {
                targetItem.classList.add('active');
                
                // Scroll to the selected item when requested (e.g., loading from hash or navigation)
                if (shouldScroll || isLoadingFromHash) {
                    // Try immediate scroll first
                    setTimeout(() => {
                        const item = document.querySelector(`[data-problem-id="${problemId}"]`);
                        if (item) {
                            item.scrollIntoView({
                                behavior: 'smooth',
                                block: 'center'
                            });
                        }
                    }, 100);
                    
                    // Backup scroll with longer delay
                    setTimeout(() => {
                        const item = document.querySelector(`[data-problem-id="${problemId}"]`);
                        if (item) {
                            item.scrollIntoView({
                                behavior: 'smooth',
                                block: 'center'
                            });
                        }
                    }, 500);
                }
            }

            currentProblemId = problemId;
            
            // Update URL hash with current state (only if not loading from hash to prevent loops)
            if (!isLoadingFromHash) {
                const searchText = document.getElementById('searchInput').value.trim();
                updateHash(problemId, searchText, currentDifficultyFilter);
            }
            
            await displayProblem(problemData);
        }

        // Check if local PDF file exists
        function getLocalPdfPath(contest, title, index) {
            // Clean contest and title for filename
            const cleanContest = contest.replace(/[<>:"/\\|?*]/g, '').trim();
            const cleanTitle = title.replace(/[<>:"/\\|?*]/g, '').trim();

            // Create filename pattern: [contest] - [title] - [index].pdf
            const filename = `[${cleanContest}] - [${cleanTitle}] - [${index}].pdf`;
            const pdfPath = `./pdfs/${filename}`;

            return pdfPath;
        }

        // Check if local PDF file exists by trying to load it
        async function checkLocalPdfExists(pdfPath) {
            // Check cache first
            if (localPdfCache.has(pdfPath)) {
                return localPdfCache.get(pdfPath);
            }

            try {
                const response = await fetch(pdfPath, { method: 'HEAD' });
                const exists = response.ok;
                localPdfCache.set(pdfPath, exists);
                return exists;
            } catch (error) {
                localPdfCache.set(pdfPath, false);
                return false;
            }
        }

        // Convert Google Drive preview URL to embed URL
        function convertGoogleDriveUrl(url) {
            if (url.includes('drive.google.com/file/d/')) {
                // Extract file ID from Google Drive URL
                const fileIdMatch = url.match(/\/d\/([a-zA-Z0-9-_]+)/);
                if (fileIdMatch) {
                    const fileId = fileIdMatch[1];
                    // Try different Google Drive embed formats
                    return {
                        embed: `https://drive.google.com/file/d/${fileId}/preview`,
                        view: `https://drive.google.com/file/d/${fileId}/view`,
                        download: `https://drive.google.com/uc?export=download&id=${fileId}`,
                        original: url
                    };
                }
            }
            return {
                embed: url,
                view: url,
                download: url,
                original: url
            };
        }

        // Check if URL is a Google Drive link
        function isGoogleDriveUrl(url) {
            return url.includes('drive.google.com');
        }

        // Process HTML content to fix relative image URLs and style sections
        function processHtmlContent(htmlContent) {
            // Create a temporary div to parse HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlContent;

            // Find all img tags
            const images = tempDiv.querySelectorAll('img');
            images.forEach(img => {
                const src = img.getAttribute('src');
                if (src) {
                    // Skip transformation for local images (local-imgs folder)
                    if (src.includes('local-imgs')) {
                        console.log('Skipping local image:', src);
                        return;
                    }

                    // Store original src for debugging
                    const originalSrc = src;

                    // Handle relative URLs starting with / (like /martor/...)
                    if (src.startsWith('/') && !src.startsWith('//')) {
                        const newSrc = 'https://tinhoctre.vn' + src;
                        img.setAttribute('src', newSrc);
                        console.log('Fixed relative URL:', originalSrc, '->', newSrc);
                    }
                    // Handle relative URLs without leading slash
                    else if (!src.startsWith('http') && !src.startsWith('//') && !src.startsWith('data:') && !src.includes('local-imgs')) {
                        const newSrc = 'https://tinhoctre.vn/' + src;
                        img.setAttribute('src', newSrc);
                        console.log('Fixed relative URL (no slash):', originalSrc, '->', newSrc);
                    }
                }
            });

            // Style sections like Codeforces/LeetCode
            styleSections(tempDiv);

            return tempDiv.innerHTML;
        }

        // Style sections with Codeforces/LeetCode design
        function styleSections(container) {
            const headers = container.querySelectorAll('h5, h6');

            headers.forEach(header => {
                const headerText = header.textContent.toLowerCase().trim();
                let sectionClass = '';

                // Determine section type
                if (headerText.includes('input')) {
                    sectionClass = 'input-section';
                } else if (headerText.includes('output')) {
                    sectionClass = 'output-section';
                } else if (headerText.includes('example')) {
                    sectionClass = 'examples-section';
                } else if (headerText.includes('explanation')) {
                    sectionClass = 'explanation-section';
                } else {
                    return; // Skip non-standard headers
                }

                // Create section container
                const sectionContainer = document.createElement('div');
                sectionContainer.className = `section-container ${sectionClass}`;

                // Create section header
                const sectionHeader = document.createElement('div');
                sectionHeader.className = 'section-header';
                sectionHeader.textContent = header.textContent;

                // Create section content
                const sectionContent = document.createElement('div');
                sectionContent.className = 'section-content';

                // Collect content until next header
                let nextElement = header.nextElementSibling;
                const contentElements = [];

                while (nextElement && !['H5', 'H6'].includes(nextElement.tagName)) {
                    contentElements.push(nextElement);
                    nextElement = nextElement.nextElementSibling;
                }

                // Process content elements
                let i = 0;
                while (i < contentElements.length) {
                    const element = contentElements[i];

                    // Check for Sample input/output pattern
                    if (element.tagName === 'P' && element.innerHTML.includes('<strong>Sample')) {
                        const sampleContainer = document.createElement('div');
                        sampleContainer.className = 'sample-container';

                        const sampleLabel = document.createElement('div');
                        sampleLabel.className = 'sample-label';
                        sampleLabel.textContent = element.querySelector('strong').textContent;
                        sampleContainer.appendChild(sampleLabel);

                        // Check if next element is a <pre> with sample data
                        if (i + 1 < contentElements.length && contentElements[i + 1].tagName === 'PRE') {
                            const sampleContent = document.createElement('div');
                            sampleContent.className = 'sample-content';
                            sampleContent.textContent = contentElements[i + 1].textContent.trim();

                            // Add copy button
                            const copyButton = document.createElement('button');
                            copyButton.className = 'copy-button';
                            copyButton.textContent = 'Copy';
                            copyButton.onclick = () => {
                                navigator.clipboard.writeText(sampleContent.textContent);
                                copyButton.textContent = 'Copied!';
                                setTimeout(() => copyButton.textContent = 'Copy', 1000);
                            };

                            sampleContainer.appendChild(sampleContent);
                            sampleContainer.appendChild(copyButton);
                            i++; // Skip the <pre> element
                        }

                        sectionContent.appendChild(sampleContainer);
                    } else {
                        sectionContent.appendChild(element.cloneNode(true));
                    }
                    i++;
                }

                // Assemble section
                sectionContainer.appendChild(sectionHeader);
                sectionContainer.appendChild(sectionContent);

                // Replace original header and content
                header.parentNode.insertBefore(sectionContainer, header);

                // Remove original elements
                header.remove();
                contentElements.forEach(el => {
                    if (el.parentNode) el.remove();
                });
            });
        }

        // Handle PDF load error
        function handlePdfError(iframe, originalUrl) {
            const fallbackDiv = iframe.nextElementSibling;
            if (fallbackDiv && fallbackDiv.classList.contains('pdf-fallback')) {
                iframe.style.display = 'none';
                fallbackDiv.classList.add('show');
            }
        }

        // Handle image load errors
        function handleImageError(img) {
            const src = img.getAttribute('src');
            console.log('Image failed to load:', src);

            if (src && src.includes('local-imgs')) {
                // For local images, show a placeholder
                img.style.border = '2px dashed #f39c12';
                img.style.background = '#fff3cd';
                img.style.padding = '20px';
                img.style.minHeight = '100px';
                img.style.display = 'flex';
                img.style.alignItems = 'center';
                img.style.justifyContent = 'center';
                img.alt = 'Local image not available: ' + src.split('/').pop();

                // Create error message
                const errorDiv = document.createElement('div');
                errorDiv.innerHTML = `
                    <div style="text-align: center; color: #856404; font-style: italic;">
                        <i class="fas fa-image" style="font-size: 2em; margin-bottom: 10px; display: block;"></i>
                        Local image not available<br>
                        <small>${src.split('/').pop()}</small>
                    </div>
                `;
                img.parentNode.insertBefore(errorDiv, img);
                img.style.display = 'none';
            } else {
                // For other images, try alternative approaches or show error
                img.style.border = '2px dashed #dc3545';
                img.style.background = '#f8d7da';
                img.style.padding = '20px';
                img.alt = 'Image failed to load: ' + src;
            }
        }

        // Display problem content
        async function displayProblem(problemData) {
            const contentArea = document.getElementById('contentArea');

            if (problemData.html) {
                // Display HTML content
                const currentLang = getCurrentLanguage();
                const title = currentLang === 'en' && problemData.titleTranslated 
                    ? problemData.titleTranslated 
                    : problemData.title || 'B√†i t·∫≠p';

                // Process HTML content to fix image URLs and translate if needed
                let processedHtml = processHtmlContent(problemData.html);
                
                // If English is selected and we don't have translated HTML, translate it
                if (currentLang === 'en' && !problemData.htmlTranslated) {
                    translateDynamicContent(problemData);
                    processedHtml = problemData.htmlTranslated || processedHtml;
                } else if (currentLang === 'en' && problemData.htmlTranslated) {
                    processedHtml = processHtmlContent(problemData.htmlTranslated);
                }

                contentArea.innerHTML = `
                    <div class="problem-content active">
                        <h1>${title}</h1>
                        <div class="problem-html">
                            ${processedHtml}
                        </div>
                    </div>
                `;

                // Handle image load errors
                const images = contentArea.querySelectorAll('img');
                images.forEach(img => {
                    img.onerror = function () {
                        handleImageError(this);
                    };
                });

                // Re-render MathJax
                if (window.MathJax) {
                    MathJax.Hub.Queue(["Typeset", MathJax.Hub, contentArea]);
                }
            } else if (problemData.pdf) {
                // Display PDF content with local file priority
                const currentLang = getCurrentLanguage();
                const title = currentLang === 'en' && problemData.titleTranslated 
                    ? problemData.titleTranslated 
                    : problemData.title || 'B√†i t·∫≠p';
                const contest = currentLang === 'en' && problemData.contestTranslated 
                    ? problemData.contestTranslated 
                    : problemData.contest || '';
                const index = problemData.index || 1;

                // Check for local PDF file first
                const localPdfPath = getLocalPdfPath(contest, title, index);
                const hasLocalPdf = await checkLocalPdfExists(localPdfPath);

                if (hasLocalPdf) {
                    // Use local PDF file
                    contentArea.innerHTML = `
                        <div class="problem-content active">
                            <h1>${title} <span class="local-indicator">üìÅ Local</span></h1>
                            <div class="pdf-content">
                                <iframe class="pdf-container" src="${localPdfPath}" frameborder="0" allowfullscreen></iframe>
                                <div class="pdf-fallback">
                                    <div class="icon">üìÑ</div>
                                    <div class="message">
                                        <strong>Kh√¥ng th·ªÉ hi·ªÉn th·ªã PDF trong tr√¨nh duy·ªát</strong><br>
                                        File PDF ƒë√£ ƒë∆∞·ª£c t·∫£i v·ªÅ m√°y nh∆∞ng tr√¨nh duy·ªát kh√¥ng th·ªÉ hi·ªÉn th·ªã
                                    </div>
                                    <div style="margin-top: 20px;">
                                        <a href="${localPdfPath}" target="_blank" class="link" style="margin: 5px;">
                                            <i class="fas fa-external-link-alt"></i> M·ªü trong tab m·ªõi
                                        </a>
                                        <a href="${localPdfPath}" download class="link" style="margin: 5px;">
                                            <i class="fas fa-download"></i> T·∫£i xu·ªëng
                                        </a>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;

                    // Add error handling for iframe
                    setTimeout(() => {
                        const iframe = contentArea.querySelector('.pdf-container');
                        if (iframe) {
                            iframe.onload = function () {
                                try {
                                    setTimeout(() => {
                                        if (iframe.offsetHeight < 100) {
                                            handlePdfError(iframe, localPdfPath);
                                        }
                                    }, 2000);
                                } catch (e) {
                                    handlePdfError(iframe, localPdfPath);
                                }
                            };

                            iframe.onerror = function () {
                                handlePdfError(iframe, localPdfPath);
                            };
                        }
                    }, 100);
                } else {
                    // Fallback to Google Drive or original PDF URL
                    const pdfUrls = convertGoogleDriveUrl(problemData.pdf);
                    const isGoogleDrive = isGoogleDriveUrl(problemData.pdf);
                    const expectedFilename = `[${contest}] - [${title}] - [${index}].pdf`;

                    if (isGoogleDrive) {
                        // For Google Drive files, show fallback immediately with multiple options
                        contentArea.innerHTML = `
                            <div class="problem-content active">
                                <h1>${title}</h1>
                                <div class="pdf-content">
                                    <div class="pdf-fallback show">
                                        <div class="icon">üìÑ</div>
                                        <div class="message">
                                            <strong>File PDF t·ª´ Google Drive</strong><br>
                                            Do h·∫°n ch·∫ø b·∫£o m·∫≠t, kh√¥ng th·ªÉ hi·ªÉn th·ªã tr·ª±c ti·∫øp trong tr√¨nh duy·ªát<br>
                                            <small style="color: #666; margin-top: 10px; display: block;">
                                                üí° File PDF ch∆∞a ƒë∆∞·ª£c t·∫£i v·ªÅ local folder<br>
                                                T√™n file mong ƒë·ª£i: <code style="background: #f0f0f0; padding: 2px 4px; border-radius: 3px;">${expectedFilename}</code>
                                            </small>
                                        </div>
                                        <div style="margin-top: 20px;">
                                            <a href="${pdfUrls.view}" target="_blank" class="link" style="margin: 5px;">
                                                <i class="fas fa-eye"></i> Xem tr√™n Google Drive
                                            </a>
                                            <a href="${pdfUrls.download}" target="_blank" class="link" style="margin: 5px;">
                                                <i class="fas fa-download"></i> T·∫£i xu·ªëng
                                            </a>
                                        </div>
                                        <div style="margin-top: 15px;">
                                            <button onclick="tryEmbedPdf('${pdfUrls.embed}')" class="link" style="border: none; cursor: pointer;">
                                                <i class="fas fa-sync"></i> Th·ª≠ hi·ªÉn th·ªã trong tr√¨nh duy·ªát
                                            </button>
                                        </div>
                                        <iframe id="pdf-embed" class="pdf-container" style="display: none;" frameborder="0"></iframe>
                                    </div>
                                </div>
                            </div>
                        `;
                    } else {
                        // For regular PDF files, try to embed directly
                        contentArea.innerHTML = `
                            <div class="problem-content active">
                                <h1>${title}</h1>
                                <div class="pdf-content">
                                    <iframe class="pdf-container" src="${pdfUrls.embed}" frameborder="0" allowfullscreen></iframe>
                                    <div class="pdf-fallback">
                                        <div class="icon">üìÑ</div>
                                        <div class="message">
                                            <strong>Kh√¥ng th·ªÉ hi·ªÉn th·ªã PDF trong tr√¨nh duy·ªát</strong><br>
                                            Tr√¨nh duy·ªát c√≥ th·ªÉ kh√¥ng h·ªó tr·ª£ hi·ªÉn th·ªã file PDF n√†y
                                        </div>
                                        <a href="${problemData.pdf}" target="_blank" class="link">
                                            <i class="fas fa-external-link-alt"></i> M·ªü trong tab m·ªõi
                                        </a>
                                    </div>
                                </div>
                            </div>
                        `;

                        // Add error handling for iframe
                        setTimeout(() => {
                            const iframe = contentArea.querySelector('.pdf-container');
                            if (iframe) {
                                iframe.onload = function () {
                                    try {
                                        setTimeout(() => {
                                            if (iframe.offsetHeight < 100) {
                                                handlePdfError(iframe, problemData.pdf);
                                            }
                                        }, 2000);
                                    } catch (e) {
                                        handlePdfError(iframe, problemData.pdf);
                                    }
                                };

                                iframe.onerror = function () {
                                    handlePdfError(iframe, problemData.pdf);
                                };
                            }
                        }, 100);
                    }
                }
            }
        }

        // Try to embed PDF (for Google Drive files)
        function tryEmbedPdf(embedUrl) {
            const iframe = document.getElementById('pdf-embed');
            const fallback = document.querySelector('.pdf-fallback');

            if (iframe && fallback) {
                iframe.src = embedUrl;
                iframe.style.display = 'block';

                // Hide the fallback temporarily
                fallback.style.opacity = '0.5';

                // Check if it loads successfully
                setTimeout(() => {
                    try {
                        if (iframe.offsetHeight < 100) {
                            // Failed to load, show fallback again
                            iframe.style.display = 'none';
                            fallback.style.opacity = '1';

                            // Add error message
                            const errorMsg = document.createElement('div');
                            errorMsg.style.cssText = 'color: #dc3545; margin-top: 10px; font-size: 14px;';
                            errorMsg.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Kh√¥ng th·ªÉ t·∫£i PDF. Vui l√≤ng s·ª≠ d·ª•ng c√°c li√™n k·∫øt b√™n tr√™n.';
                            fallback.appendChild(errorMsg);
                        } else {
                            // Success, hide fallback
                            fallback.style.display = 'none';
                        }
                    } catch (e) {
                        iframe.style.display = 'none';
                        fallback.style.opacity = '1';
                    }
                }, 3000);
            }
        }

        // Search functionality
        document.getElementById('searchInput').addEventListener('input', async (e) => {
            const filterText = e.target.value.trim();
            await renderProblemList(filterText);
            
            // Update hash with current search and filter state (only if not loading from hash)
            if (!isLoadingFromHash) {
                updateHash(currentProblemId, filterText, currentDifficultyFilter);
            }
        });

        // Difficulty filter functionality
        document.getElementById('difficultyFilter').addEventListener('change', async (e) => {
            currentDifficultyFilter = e.target.value;
            const filterText = document.getElementById('searchInput').value.trim();
            await renderProblemList(filterText);
            
            // Update hash with current search and filter state (only if not loading from hash)
            if (!isLoadingFromHash) {
                updateHash(currentProblemId, filterText, currentDifficultyFilter);
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'f') {
                e.preventDefault();
                document.getElementById('searchInput').focus();
            }
        });

        // Handle hash changes (back/forward navigation)
        window.addEventListener('hashchange', async () => {
            if (Object.keys(allProblems).length > 0) {
                isLoadingFromHash = true;
                const hashParams = getHashParams();
                
                // Restore search input
                if (hashParams.search) {
                    document.getElementById('searchInput').value = hashParams.search;
                }
                
                // Restore difficulty filter
                if (hashParams.difficulty) {
                    currentDifficultyFilter = hashParams.difficulty;
                    document.getElementById('difficultyFilter').value = hashParams.difficulty;
                }
                
                // Render problem list with current filters first
                await renderProblemList(hashParams.search);
                
                // Then load specific problem if specified with scroll
                if (hashParams.problemId) {
                    const problemUrl = Object.keys(allProblems).find(url => 
                        url.split('/').pop() === hashParams.problemId
                    );
                    if (problemUrl) {
                        setTimeout(async () => {
                            isLoadingFromHash = false; // Reset flag before calling selectProblem
                            await selectProblem(hashParams.problemId, problemUrl, allProblems[problemUrl], true);
                        }, 200);
                    } else {
                        isLoadingFromHash = false;
                    }
                } else {
                    isLoadingFromHash = false;
                }
            }
        });

        // Language toggle functionality
        document.getElementById('languageToggle').addEventListener('click', async (event) => {
            // Prevent multiple clicks during translation
            const button = event.target.closest('#languageToggle');
            if (button.disabled || isTranslating) {
                console.log('Language toggle blocked: translation in progress');
                return;
            }
            
            try {
                // Disable button during translation
                button.disabled = true;
                button.style.opacity = '0.6';
                button.style.cursor = 'not-allowed';
                
                console.log('Language toggle started');
                const newLang = currentLanguage === 'vi' ? 'en' : 'vi';
                setCurrentLanguage(newLang);
                await translatePageElements();
                
                // Re-render the problem list with translated content
                const filterText = document.getElementById('searchInput').value.trim();
                await renderProblemList(filterText);
                
                // If there's a currently selected problem, refresh its display with translated content
                if (currentProblemId && Object.keys(allProblems).length > 0) {
                    const problemUrl = Object.keys(allProblems).find(url => 
                        url.split('/').pop() === currentProblemId
                    );
                    if (problemUrl) {
                        await displayProblem(allProblems[problemUrl]);
                    }
                }
                console.log('Language toggle completed successfully');
            } catch (error) {
                console.error('Error during language toggle:', error);
                // Reset translation flag on error
                isTranslating = false;
            } finally {
                // Re-enable button
                button.disabled = false;
                button.style.opacity = '1';
                button.style.cursor = 'pointer';
            }
        });

        // Function to reset translation state (for debugging)
        function resetTranslationState() {
            console.log('Resetting translation state. Was translating:', isTranslating);
            isTranslating = false;
            const button = document.getElementById('languageToggle');
            if (button) {
                button.disabled = false;
                button.style.opacity = '1';
                button.style.cursor = 'pointer';
            }
            console.log('Translation state reset complete');
        }

        // Make reset function available globally for debugging
        window.resetTranslationState = resetTranslationState;

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize language
            currentLanguage = getCurrentLanguage();
            updateLanguageToggleButton();
            loadProblems();
        });
    </script>
</body>

</html>